{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "6f463156-deaa-4464-af2e-d129d5a32893",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'FitnessPredictor' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[1], line 100\u001b[0m\n\u001b[0;32m     95\u001b[0m SEQUENCE_LENGTH \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mlen\u001b[39m(TARGET_SEQ)\n\u001b[0;32m     97\u001b[0m \u001b[38;5;66;03m# 1. Instantiate the Genetic Optimizer, passing the FitnessPredictor class\u001b[39;00m\n\u001b[0;32m     98\u001b[0m \u001b[38;5;66;03m# NOTE: We assume the FitnessPredictor class is already defined in the cell above this one.\u001b[39;00m\n\u001b[0;32m     99\u001b[0m ga \u001b[38;5;241m=\u001b[39m GeneticOptimizer(\n\u001b[1;32m--> 100\u001b[0m     predictor_class\u001b[38;5;241m=\u001b[39mFitnessPredictor, \u001b[38;5;66;03m# Class name from previous cell\u001b[39;00m\n\u001b[0;32m    101\u001b[0m     seq_len\u001b[38;5;241m=\u001b[39mSEQUENCE_LENGTH,\n\u001b[0;32m    102\u001b[0m     pop_size\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m100\u001b[39m,\n\u001b[0;32m    103\u001b[0m     max_generations\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m200\u001b[39m,\n\u001b[0;32m    104\u001b[0m     mutation_rate\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0.01\u001b[39m,\n\u001b[0;32m    105\u001b[0m     elitism_count\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m5\u001b[39m\n\u001b[0;32m    106\u001b[0m )\n\u001b[0;32m    108\u001b[0m \u001b[38;5;66;03m# 2. Run the optimization\u001b[39;00m\n\u001b[0;32m    109\u001b[0m optimized_sequence, final_fitness \u001b[38;5;241m=\u001b[39m ga\u001b[38;5;241m.\u001b[39mevolve()\n",
      "\u001b[1;31mNameError\u001b[0m: name 'FitnessPredictor' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "class GeneticOptimizer:\n",
    "    \"\"\"\n",
    "    Implements a Genetic Algorithm (GA) for DNA sequence optimization.\n",
    "    Based on Algorithm 1 .\n",
    "    \"\"\"\n",
    "    \n",
    "    def __init__(self, predictor_class, seq_len=10, pop_size=50, max_generations=100, \n",
    "                 mutation_rate=0.05, elitism_count=2):\n",
    "        \"\"\"Initializes the GA parameters.\"\"\"\n",
    "        # Use an instance of the class defined in the previous cell\n",
    "        predictor_instance = predictor_class(target_sequence='ATTGCAGCTA')\n",
    "        self.F = predictor_instance.evaluate_fitness \n",
    "        self.alphabet = ['A', 'T', 'C', 'G']\n",
    "        self.seq_len = seq_len\n",
    "        self.pop_size = pop_size\n",
    "        self.max_generations = max_generations\n",
    "        self.mutation_rate = mutation_rate\n",
    "        self.elitism_count = elitism_count\n",
    "        self.population = []\n",
    "\n",
    "    def initialize_population(self):\n",
    "        \"\"\"Initializes population P_0 with random sequences.\"\"\"\n",
    "        self.population = [''.join(random.choice(self.alphabet) \n",
    "                                   for _ in range(self.seq_len)) \n",
    "                           for _ in range(self.pop_size)]\n",
    "\n",
    "    def evaluate_and_select(self):\n",
    "        \"\"\"Evaluates fitness and selects parents based on Tournament Selection [cite: 44-45].\"\"\"\n",
    "        fitnesses = [self.F(seq) for seq in self.population]\n",
    "        \n",
    "        sorted_pop = sorted(zip(self.population, fitnesses), key=lambda x: x[1], reverse=True)\n",
    "        self.population = [item[0] for item in sorted_pop]\n",
    "        best_sequence = sorted_pop[0][0]\n",
    "        best_fitness = sorted_pop[0][1]\n",
    "\n",
    "        # Tournament Selection\n",
    "        parents = []\n",
    "        for _ in range(self.pop_size):\n",
    "            tournament_candidates = random.sample(self.population, 3)\n",
    "            winner = max(tournament_candidates, key=self.F)\n",
    "            parents.append(winner)\n",
    "            \n",
    "        return parents, best_sequence, best_fitness\n",
    "\n",
    "    def crossover(self, parent_a: str, parent_b: str) -> tuple[str, str]:\n",
    "        \"\"\"Performs one-point crossover (recombination) [cite: 42, 65-66].\"\"\"\n",
    "        split = random.randint(1, self.seq_len - 1) \n",
    "        child1 = parent_a[:split] + parent_b[split:]\n",
    "        child2 = parent_b[:split] + parent_a[split:]\n",
    "        return child1, child2\n",
    "\n",
    "    def mutate(self, sequence: str) -> str:\n",
    "        \"\"\"Introduces random genetic alterations (Mutation) [cite: 40, 69-72].\"\"\"\n",
    "        mutated_seq = list(sequence)\n",
    "        for i in range(self.seq_len):\n",
    "            if random.random() < self.mutation_rate:\n",
    "                original_base = mutated_seq[i]\n",
    "                new_base = random.choice([b for b in self.alphabet if b != original_base])\n",
    "                mutated_seq[i] = new_base\n",
    "        return \"\".join(mutated_seq)\n",
    "\n",
    "    def evolve(self):\n",
    "        \"\"\"The main evolutionary loop [cite: 56-79].\"\"\"\n",
    "        self.initialize_population()\n",
    "        \n",
    "        print(\"Starting AI-Driven Genetic Algorithm Optimization...\")\n",
    "        \n",
    "        for generation in range(1, self.max_generations + 1):\n",
    "            parents, s_best, f_best = self.evaluate_and_select()\n",
    "            \n",
    "            next_generation = [] \n",
    "            next_generation.extend(self.population[:self.elitism_count]) # Elitism\n",
    "\n",
    "            for i in range(self.pop_size // 2):\n",
    "                parent_a = parents[i*2]\n",
    "                parent_b = parents[i*2 + 1]\n",
    "                \n",
    "                child1, child2 = self.crossover(parent_a, parent_b)\n",
    "                \n",
    "                mutated_child1 = self.mutate(child1)\n",
    "                mutated_child2 = self.mutate(child2)\n",
    "                \n",
    "                next_generation.extend([mutated_child1, mutated_child2])\n",
    "            \n",
    "            self.population = next_generation[:self.pop_size]\n",
    "\n",
    "            if generation % 20 == 0 or generation == self.max_generations:\n",
    "                 print(f\"Gen {generation:3d}: Best Fitness = {f_best:.4f}, Best Seq = {s_best}\")\n",
    "        \n",
    "        return s_best, f_best\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    # Define parameters\n",
    "    TARGET_SEQ = \"ATTGCAGCTA\" # This must match the target in FitnessPredictor\n",
    "    SEQUENCE_LENGTH = len(TARGET_SEQ)\n",
    "    \n",
    "    # 1. Instantiate the Genetic Optimizer, passing the FitnessPredictor class\n",
    "    # NOTE: We assume the FitnessPredictor class is already defined in the cell above this one.\n",
    "    ga = GeneticOptimizer(\n",
    "        predictor_class=FitnessPredictor, # Class name from previous cell\n",
    "        seq_len=SEQUENCE_LENGTH,\n",
    "        pop_size=100,\n",
    "        max_generations=200,\n",
    "        mutation_rate=0.01,\n",
    "        elitism_count=5\n",
    "    )\n",
    "    \n",
    "    # 2. Run the optimization\n",
    "    optimized_sequence, final_fitness = ga.evolve()\n",
    "\n",
    "    print(\"\\n--- Optimization Complete ---\")\n",
    "    print(f\"Target Sequence (Conceptual Optimum): {TARGET_SEQ}\")\n",
    "    print(f\"Optimized Sequence (S_best): {optimized_sequence}\")\n",
    "    print(f\"Final Predicted Fitness: {final_fitness:.4f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c9418b0e-3914-4896-8cbc-35ef2ac36289",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
